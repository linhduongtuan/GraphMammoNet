# -*- coding: utf-8 -*-
"""Edge_detection_2class.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GXjpNa289aOJ0mVIx17awm5Cq9-bG47a
"""

#mounting on drive
from google.colab import drive
drive.mount('/content/drive',force_remount=True)

import numpy as np
import cv2
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
import glob

#applying filter on a single image
def apply_filter(filename,filter):

  print("reading file---> "+str(filename))
  img=cv2.imread(filename,cv2.IMREAD_GRAYSCALE)
  
  #img=cv2.resize(img,(250,250))  
  #comment out the above line if there is memory issue i.e. need to resize all images to smaller dim

  h, w = img.shape
  print("shape: "+str(h)+" x "+str(w)+"\n")
  # define filters
  horizontal = filter
  vertical = np.transpose(filter)

  # define images with 0s
  newhorizontalImage = np.zeros((h, w))
  newverticalImage = np.zeros((h, w))
  newgradientImage = np.zeros((h, w))

  # offset by 1
  for i in range(1, h - 1):
      for j in range(1, w - 1):
          horizontalGrad = (horizontal[0, 0] * img[i - 1, j - 1]) + \
                          (horizontal[0, 1] * img[i - 1, j]) + \
                          (horizontal[0, 2] * img[i - 1, j + 1]) + \
                          (horizontal[1, 0] * img[i, j - 1]) + \
                          (horizontal[1, 1] * img[i, j]) + \
                          (horizontal[1, 2] * img[i, j + 1]) + \
                          (horizontal[2, 0] * img[i + 1, j - 1]) + \
                          (horizontal[2, 1] * img[i + 1, j]) + \
                          (horizontal[2, 2] * img[i + 1, j + 1])

          newhorizontalImage[i - 1, j - 1] = abs(horizontalGrad)

          verticalGrad = (vertical[0, 0] * img[i - 1, j - 1]) + \
                        (vertical[0, 1] * img[i - 1, j]) + \
                        (vertical[0, 2] * img[i - 1, j + 1]) + \
                        (vertical[1, 0] * img[i, j - 1]) + \
                        (vertical[1, 1] * img[i, j]) + \
                        (vertical[1, 2] * img[i, j + 1]) + \
                        (vertical[2, 0] * img[i + 1, j - 1]) + \
                        (vertical[2, 1] * img[i + 1, j]) + \
                        (vertical[2, 2] * img[i + 1, j + 1])

          newverticalImage[i - 1, j - 1] = abs(verticalGrad)

          # Edge Magnitude
          mag = np.sqrt(pow(horizontalGrad, 2.0) + pow(verticalGrad, 2.0))
          newgradientImage[i - 1, j - 1] = mag

  return newgradientImage

#function for creating all edge-images of a directory
def convert_edge_dir(sourcedir,destdir):
  print("\n\n---reading directory "+sourcedir+"---\n")
  filecnt=1 
  for filename in glob.glob(sourcedir+'/*'):
  	#applying Prewitt filter
  	#for appyling any other filter change filter value accordingly i.e. the 2nd args for apply_filter()
    imagemat=apply_filter(filename,np.array([[-1,0,1],[-1,0,1],[-1,0,1]]))
    cv2.imwrite(destdir+'/img-'+str(filecnt)+'.png',imagemat) #create the edge image and store it to consecutive filenames
    filecnt+=1
  print("\n\n--saved in "+destdir+"--\n")

#function for creating all edge-images under both covid and non-covid directories 
#since 2-class so COVID and NON-COVID present
def convert_edge_all_dir(coviddir,ncoviddir,destdir):
	
  convert_edge_dir(coviddir,destdir+'/COVID')
  convert_edge_dir(ncoviddir,destdir+'/NON-COVID')
  print("\n---edge detection completed--\n")


#adjust the source paths accordingly
coviddir='/content/drive/MyDrive/Github_COVID/CT_COVID/CT_COVID' #source path for covid dir
ncoviddir='/content/drive/MyDrive/Github_COVID/CT_NonCOVID/CT_NonCOVID' #source path for non-covid dir


#adjust the destination directory accordingly
#directory naming format--> <dataset_name(not necessary conventional)>_edge/<filtername>
destdir='/content/drive/My Drive/Github_edge/Pretwitt' 

convert_edge_all_dir(coviddir,ncoviddir,destdir)

